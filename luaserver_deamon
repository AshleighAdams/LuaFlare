#! /bin/sh

# LUASERVER
# Maintainer: Kate Adams
# Authors: Kate Adams

### BEGIN INIT INFO
# Provides:          luaserver
# Required-Start:    $local_fs $remote_fs $network $syslog
# Required-Stop:     $local_fs $remote_fs $network $syslog
# Default-Start:     2 3 4 5
# Default-Stop:      0 1 6
# Short-Description: LuaServer web server
# Description:       LuaServer web server
### END INIT INFO


###
# sudo cp luaserver_deamon /etc/init.d/luaserver
# DO NOT EDIT THIS FILE!
# This file will be overwritten on update.
# Instead add/change your variables in /etc/default/luaserver
###

### Modified from GitLab's

# Read configuration variable file if it is present
test -f /etc/default/luaserver && . /etc/default/luaserver
. /lib/lsb/init-functions

# Script variable names should be lower-case not to conflict with
# internal /bin/sh variables such as PATH, EDITOR or SHELL.

if [ ! -n "$app_user" ]; then
	app_user="luaserver"
fi
if [ ! -n "$app_root" ]; then
	app_root="/home/$app_user/LuaServer"
fi
if [ ! -n "$pid_path" ]; then
	pid_path="$app_root/tmp/pids"
fi
if [ ! -n "$web_server_pid_path" ]; then
	web_server_pid_path="$pid_path/luaserver.pid"
fi


# Switch to the app_user if it is not he/she who is running the script.
if [ "$USER" != "$app_user" ]; then
	sudo -u "$app_user" -H -i $0 "$@"; exit;
fi

# Switch to the luaserver path, exit on failure.
if ! cd "$app_root" ; then
	log_action_msg "Failed to cd into $app_root, exiting!" || true
	exit 1
fi


### Init Script functions

## Gets the pids from the files
check_pids(){
	if ! mkdir -p "$pid_path"; then
		log_progress_msg "(failed to create path $pid_path)" || true
		log_end_msg 1 || true
		exit 1
	fi
	# If there exists a file which should hold the value of the Unicorn pid: read it.
	if [ -f "$web_server_pid_path" ]; then
		wpid=$(cat "$web_server_pid_path")
	else
		wpid=0
	fi
}

## Called when we have started the two processes and are waiting for their pid files.
wait_for_pids(){
	# We are sleeping a bit here mostly because sidekiq is slow at writing it's pid
	i=0;
	while [ ! -f $web_server_pid_path ]; do
		sleep 0.1;
		i=$((i+1))
		if [ $((i%10)) = 0 ]; then
			echo -n "."
		elif [ $((i)) = 301 ]; then
			log_progress_msg "(process timed out)" || true
			log_end_msg 1 || true
			exit 1;
		fi
	done
	echo
}

# We use the pids in so many parts of the script it makes sense to always check them.
# Only after start() is run should the pids change. Sidekiq sets it's own pid.
check_pids


## Checks whether the different parts of the service are already running or not.
check_status(){
	check_pids
	# If the web server is running kill -0 $wpid returns true, or rather 0.
	# Checks of *_status should only check for == 0 or != 0, never anything else.
	if [ $wpid -ne 0 ]; then
		kill -0 "$wpid" 2>/dev/null
		web_status="$?"
	else
		web_status="-1"
	fi
	if [ $web_status = 0 ]; then
		luaserver_status=0
	else
		# http://refspecs.linuxbase.org/LSB_4.1.0/LSB-Core-generic/LSB-Core-generic/iniscrptact.html
		# code 3 means 'program is not running'
		luaserver_status=3
	fi
}

## Check for stale pids and remove them if necessary.
check_stale_pids(){
	check_status
	# If there is a pid it is something else than 0, the service is running if
	# *_status is == 0.
	if [ "$wpid" != "0" -a "$web_status" != "0" ]; then
		log_progress_msg "(removing stale web server pid)" || true
		if ! rm "$web_server_pid_path"; then
			log_progress_msg "(unable to remove stale pid)" || true
			log_end_msg 1 || true
			exit 1
		fi
	fi
}

## If no parts of the service is running, bail out.
exit_if_not_running(){
	check_stale_pids
	if [ "$web_status" != "0" ]; then
		log_progress_msg "(not running)" || true
	log_end_msg 0 || true
		exit
	fi
}

## Starts Unicorn and Sidekiq if they're not running.
start() {
	check_stale_pids
	
	# Then check if the service is running. If it is: don't start again.
	if [ "$web_status" = "0" ]; then
		log_end_msg 0 || true
		exit 0
	else
		# Start the web server
		$app_root/instance.sh start &
	fi
	
	# Wait for the pids to be planted
	wait_for_pids
}

## Asks the Unicorn and the Sidekiq if they would be so kind as to stop, if not kills them.
stop() {
	exit_if_not_running
	
	# If LuaServer is running, tell it to stop
	if [ "$web_status" = "0" ]; then
		 $app_root/instance.sh stop
	fi
	
	# If something needs to be stopped, lets wait for it to stop. Never use SIGKILL in a script.
	check_status
	if [ "$web_status" = "0" ]; then
		#sleep 1
		#check_status
		#if [ "$web_status" != "0" ]; then
		#	break
		#fi
		log_progress_msg "(failed to stop)" || true
		log_end_msg 1 || true
		exit
	fi
	
	# Cleaning up unused pids
	rm "$web_server_pid_path" 2>/dev/null
}

restart(){
	log_daemon_msg "Stopping LuaServer" "luaserver" || true
	stop
	log_end_msg 0 || true
		
	log_daemon_msg "Restarting LuaServer" "luaserver" || true
	start
	log_end_msg 0 || true
}

## Prints the status of LuaServer
print_status() {
	check_status
	
	if [ "$web_status" = "0" ]; then
			log_action_msg "LuaServer is running" || true
	else
			log_action_msg "LuaServer is not running" || true
	fi
}

### Finally the input handling.

case "$1" in
	start)
				log_daemon_msg "Starting LuaServer" "luaserver" || true
				start
				log_end_msg 0 || true
				;;
	stop)
				log_daemon_msg "Stopping LuaServer" "luaserver" || true
				stop
				log_end_msg 0 || true
				;;
	restart)
				restart				
				;;
	status)
				print_status
				exit $web_status
				;;
	*)
				log_action_msg "Usage: service luaserver {start|stop|restart|status}" || true
				exit 1
				;;
esac

exit
